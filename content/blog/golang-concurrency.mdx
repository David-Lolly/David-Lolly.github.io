---
title: Python 语言并发模式详解
slug: golang-concurrency-patterns
date: 2025-11-03
image: https://th.bing.com/th/id/OIP.0YahQc4l1uskmH4NrbPBJwHaEJ?w=289&h=180&c=7&r=0&o=7&cb=ucfimgc2&dpr=2&pid=1.7&rm=3
description: 学习 Go 语言中的并发编程模式，包括 goroutines、channels 和 select。
categories: [Go, 技术教程]
---

# Go 语言并发模式详解

Go 语言的并发模型是其最强大的特性之一，本文将详细介绍 Go 的并发编程。

## Goroutines

Goroutine 是 Go 的轻量级线程。

```go
package main

import (
    "fmt"
    "time"
)

func sayHello() {
    fmt.Println("Hello from goroutine!")
}

func main() {
    go sayHello()
    time.Sleep(time.Second)
    fmt.Println("Main function")
}
```

## Channels

Channels 用于 goroutines 之间的通信。

```go
func worker(jobs <-chan int, results chan<- int) {
    for job := range jobs {
        results <- job * 2
    }
}

func main() {
    jobs := make(chan int, 5)
    results := make(chan int, 5)

    go worker(jobs, results)

    for i := 1; i <= 5; i++ {
        jobs <- i
    }
    close(jobs)

    for i := 1; i <= 5; i++ {
        fmt.Println(<-results)
    }
}
```

## Select 语句

`select` 语句用于处理多个 channel 操作。

```go
select {
case msg1 := <-ch1:
    fmt.Println("收到消息1:", msg1)
case msg2 := <-ch2:
    fmt.Println("收到消息2:", msg2)
case <-time.After(time.Second):
    fmt.Println("超时")
}
```

## 并发模式

### Worker Pool 模式

```go
func workerPool(tasks <-chan int, results chan<- int, numWorkers int) {
    for i := 0; i < numWorkers; i++ {
        go func() {
            for task := range tasks {
                results <- processTask(task)
            }
        }()
    }
}
```

### Fan-Out/Fan-In 模式

将工作分发给多个 goroutines，然后收集结果。

## 最佳实践

- 使用 buffered channels 避免阻塞
- 总是关闭不再使用的 channels
- 使用 `sync.WaitGroup` 等待 goroutines 完成
- 避免共享内存，使用 channels 通信

## 总结

Go 的并发模型简单而强大，掌握这些模式能帮你编写高效的并发程序。
